2019:
ac:
2299简单
2304简单
2308简单
2311简单

no:
2300通过大部分，超时
2301通过大部分，超时(看答案会了，发现用并查集)
2302不会
2305(1) 没考虑等差也可以为0的情况，即存在常数数列，结果应为n
    (2) 只是单纯的用最小值作为等差，应该考虑(1, 3, 6)这种情况，2并不能作为等差，应该用gcd代替min
    (3) 学会了一行求gcd的方法
2306不会
    (1) 参考:https://blog.csdn.net/qq_44322532/article/details/104117099
    (2) 感觉这题需要讨论的太细了，考试如果有时间再慢慢想
    (3) 注意结果用long long
2307不会
2309只通过一点测试样例，不太清楚为什么运行错误
	
not do:
2303还没做
2310还没做


2018:

ac:
2274一次做出来了，但是做的很费劲，主要是不熟悉scanf等运用
2276图回溯问题，墨迹好几次终于做出来了，问题有：
    (1)scanf("%c")之前没有getchar()
    (2)回溯时候if(dfs() || dfs() || dfs() || dfs())前面的dfs返回true导致后面的dfs没有执行
2277卧槽，竟然做出来了，虽然很繁琐，有空可以看看能否简化(主要思想是根据num % k进行分组，如果暴力O(n ** 3)肯定会超时，而分组后复杂度只有O(k ** 2 + nlogn))
2279第一次提交超时，因为用的cin，cout，改成printf直接快十倍卧槽(cin会慢一点，cout慢无敌)
2281简单(签到题？)
2282简单
2291 第一次没想到用bfs(可能是好久没bfs的原因),然后出了点错(超时了),因为没有入队列之前map[index] = true;结果导致当前队列剩下许多元素重复。

no:
2280看https://blog.csdn.net/weixin_46239370/article/details/105707533，写出来发现答案是错的，有时间再想这种分类讨论的题把
    分类讨论主要看临场发挥，实在不行还是可以拿一部分分的
2285:借鉴了下思路(分象限)，在纸上画了半天，结果答案不对，这种分类讨论题我选择先放弃
2289:感觉自己做的没问题，可能是题目没读懂
2292:https://blog.csdn.net/qq_35975367/article/details/109478898,dp好难的样子


not do:
2275没做
2278没做
